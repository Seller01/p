import {FormDataExtensions} from "./form-data";
import {UrlParser} from "./url";
import {ServerValues} from "./ServerValues";

const formDataExtensions = new FormDataExtensions();
const urlParser = new UrlParser();

export class Ajax {
    /**
     *
     * @param {Object} options options
     * @param {String} options.baseUrl (default: undefined) base url of the endpoint. http://localhost:5000
     * @param {Object} options.headers (default: { 'X-Requested-With': 'XMLHttpRequest' }) an object of headers for all requests
     * @param {Object} options.postHeaders (default: {}) an object of headers for POST requests
     * @param {Object} options.getHeaders (default: {}) an object of headers for Get requests
     * @param {Boolean} options.addAntiforgeryHeader (default: false) if true, each request will have the X-XSRF-TOKEN header
     * @param {Boolean} options.localizeUrl (default: true)
     * @param {Boolean} options.localizeHeader (default: false)
     * @param {Boolean} options.localizeHeaderName (default: 'X-LANGUAGE')
     */
    constructor(options) {
        var defaults = {
            baseUrl: undefined,
            addAntiforgeryHeader: false,
            headers: {
                // this header ensures that C# code "IsAjaxRequest" will work correctly
                'X-Requested-With': 'XMLHttpRequest'
            },
            postHeaders: {},
            getHeaders: {},
            localizeUrl: true,
            localizeHeader: false,
            localizeHeaderName: 'X-LANGUAGE'
        };
        this.options = {
            baseUrl: options.baseUrl,
            addAntiforgeryHeader: options.addAntiforgeryHeader || false,
            headers: Object.assign({}, defaults.headers, options.headers),
            getHeaders: Object.assign({}, defaults.getHeaders, options.getHeaders),
            postHeaders: Object.assign({}, defaults.postHeaders, options.postHeaders),
            localizeUrl: _.isNil(options.localizeUrl) ? defaults.localizeUrl : options.localizeUrl,
            localizeHeader: _.isNil(options.localizeHeader) ? defaults.localizeHeader : options.localizeHeader,
            localizeHeaderName: _.isNil(options.localizeHeaderName) ? defaults.localizeHeaderName : options.localizeHeaderName
        };
    }
    
    _getErrors(result) {
        const res = [];
        if (result === null || result === undefined) {
            return res;
        }
        if (result.errors === null || result.errors === undefined) {
            return res;
        }
        result.errors.forEach(err => {
            res.push(err);
        });
        return res;
    }
    
    _getMessages(result) {
        const res = [];
        if (result === null || result === undefined) {
            return res;
        }
        if (result.messages === null || result.messages === undefined) {
            return res;
        }
        result.messages.forEach(m => {
            res.push(m);
        });
        return res;
    }
    
    _getResultErrorsAndMessages(result) {
        const errors = this._getErrors(result);
        const messages = this._getMessages(result);
        const res = [];
        errors.forEach(a => {
            res.push(a);
        });
        messages.forEach(a => {
            res.push(a);
        });
        return res;
    }
    
    _isSuccess(data) {
        return data.errors === undefined || data.errors === null || data.errors.length === 0;
    }
    
    /**
     * Changes a local URL to a URL with culture in it and changes the __baseUrl__ to the __this.options.baseUrl__
     * @param {String} url local URL to be converted to a URL with culture in it
     * @returns {String}
     */
    _localizeUrlWithOptionsBaseUrl(url) {
        if (!this.options.localizeUrl) {
            return url;
        }
        let path = urlParser.localizeUrl(url).toRelative(true);
        let res = '';
        let baseUrl = this.options.baseUrl;
        if (baseUrl !== undefined && baseUrl !== null) {
            if (baseUrl[baseUrl.length - 1] !== '/') {
                baseUrl += '/';
            }
            if (path[0] === '/') {
                path = path.substr(1);
            }
            res = `${baseUrl}${path}`;
        } else {
            res = path;
        }
        return res;
    }
    
    _processData(data, resolve, reject) {
        if (data['$action'] === undefined || data['$action'] === null) {
            // a Result object
            if (this._isSuccess(data)) {
                const messages = this._getMessages(data);
                if (!_.isEmpty(messages)) {
                    if (_.isNil(data.value)) {
                        data.value = {};
                    }
                    data.value.$_messages = messages;
                }
                resolve(data.value);
            } else {
                reject(this._getResultErrorsAndMessages(data));
            }
        } else {
            // a CustomResult object
            let action = data['$action'];       // REDIRECT, REFRESH, SHOW_ERROR
            let error = data['$error'];         // a string
            let url = data['$url'];             // redirect url
            if (action === 'REDIRECT') {
                window.location.href = `${window.location.protocol}//${window.location.host}${url}`;
            } else if (action === 'REFRESH') {
                // eslint-disable-next-line no-self-assign
                window.location = window.location;
            } else {
                reject(error);
            }
        }
    }
    
    _getHeaders(method) {
        const serverValues = new ServerValues().getValues();
        let shared = Object.assign({}, this.options.headers);
        let res;
        if (method.toLowerCase() === 'get') {
            var get = Object.assign({}, this.options.getHeaders);
            res = Object.assign({}, shared, get);
        } else {
            var post = Object.assign({}, this.options.postHeaders);
            res = Object.assign({}, shared, post);
            // anti-forgery for post methods
            res[serverValues['xsrf-header-name']] = serverValues['xsrf-token'];
        }
        if (this.options.localizeHeader) {
            res[this.options.localizeHeaderName] = serverValues['culture'];
        }
        return res;
    }
    
    /**
     * Sends a GET request
     * @param {String} url URL
     * @param {Object} payload data to send
     * @returns {Promise<Object>}
     */
    get(url, payload) {
        return new Promise((resolve, reject) => {
            $.ajax({
                method: 'GET',
                url: this._localizeUrlWithOptionsBaseUrl(url),
                cache: false,
                data: payload,
                contentType: false,
                headers: this._getHeaders('GET'),
                processData: false,
                error: (xhr, status, errorThrown) => {
                    reject();
                    console.log(errorThrown);
                },
                success: (data, status, xhr) => {
                    this._processData(data, resolve, reject);
                }
            });
        });
    }
    
    /**
     * Sends a POST request
     * @param {String} url URL
     * @param {Object} payload data to send
     * @returns {Promise<Object>}
     */
    post(url, payload) {
        let fd = new FormData();
        formDataExtensions.put(fd, payload);
        return new Promise((resolve, reject) => {
            $.ajax({
                method: 'POST',
                url: this._localizeUrlWithOptionsBaseUrl(url),
                cache: false,
                contentType: false,
                headers: this._getHeaders('POST'),
                data: fd,
                processData: false,
                error: (xhr, status, errorThrown) => {
                    reject();
                    console.log(errorThrown);
                },
                success: (data, status, xhr) => {
                    this._processData(data, resolve, reject);
                }
            });
        });
    }
    
    /**
     * Downloads the given URL
     * @param {String} uri URL of the file or anything to be downloaded
     * @param {String} fileNameForDownload the name of the file when downloading
     */
    downloadURI(uri, fileNameForDownload) {
        let link = document.createElement("a");
        if (fileNameForDownload !== undefined) {
            link.download = fileNameForDownload;
        }
        link.href = uri;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }
}